; ----------------------------- PROCESS MANAGEMENT SYSTEM -----------------------------

; begin globals
_SYS_PROC__PROCESSES_MAX: WORD 0x3
_SYS_PROC__PROCESSES_LIST_PTR: WORD 0x0
_SYS_PROC__RUNNING_PROCESS_ID: WORD 0x0
_SYS_PROC__CUR_PROCESSES_COUNT: WORD 0x0
; end globals



; func PROC__INIT_MANAGER: () prepares structures to hold processes
;
; stack:
; &: stack_data_ptr
; &: sp_origin
; &: cur_id
; &: ret_addr
; begin globals
PIM__TCB_PTR: WORD ?
; end globals
; begin func
PROC__INIT_MANAGER:
; begin prologue
  APUSH
; end prologue

  RSP
  SUB #2
  ST &sp_origin

  LD $_PROC__TCB_DESCR_BEGIN
  ST PIM__TCB_PTR

  LD $_SYS_PROC__PROCESSES_MAX
  ST &cur_id
  
  LD $_PROC__TCB_STACK_BEGIN
  ST &stack_data_ptr

  PIM__LOOP:
    LD #0xFF ; free thread
    ST (PIM__TCB_PTR)

    LD PIM__TCB_PTR
    ADD #4
    ST PIM__TCB_PTR

    LD &sp_origin
    ST (PIM__TCB_PTR)

    LD PIM__TCB_PTR
    ADD #2
    ST PIM__TCB_PTR

    LD &stack_data_ptr
    ST (PIM__TCB_PTR)+

    LD &stack_data_ptr
    ADD $_PROC__TCB_STACK_SIZE
    ST &stack_data_ptr

    LOOP &cur_id
    JUMP PIM__LOOP

PIM__END:
; begin epilogue
  APOP
  RET
; end epilogue
; end func PROC__INIT_MANAGER



; func PROC_INIT: (ip) create process TCB with entrypoint address ip
; 
; params: AC: ip
; return: process id or 0xFFFF if could not be created
; stack:
; &: ip
; &: proc_id
; &: ret_addr
; begin globals
PCRT__PTR: WORD ?
PCRT__BASE_PS: WORD 0x1A0 ; P | W | EI
; end globals
; begin func
PROC_INIT:
; begin prologue
  APUSH
; end prologue
  ST &ip
  ; check count
  LD $_SYS_PROC__CUR_PROCESSES_COUNT
  CMP $_SYS_PROC__PROCESSES_MAX
  BHIS PCRT__INVALID
  INC 
  ST $_SYS_PROC__CUR_PROCESSES_COUNT

  ; search for free id
  LD $_SYS_PROC__PROCESSES_MAX
  PUSH 
  LD #0xFF
  CALL $PROC_GET_NEXT_WITH_STATUS
  BMI PCRT__INVALID
  ST &proc_id+1
  CALL $PROC_GET_TCB_PTR
  ST PCRT__PTR
  POP

  CLA 
  ST (PCRT__PTR)+ ; state
  ST (PCRT__PTR)+ ; AC
  LD PCRT__BASE_PS
  ST (PCRT__PTR)+ ; PS
  LD &ip
  ST (PCRT__PTR)+ ; IP
  LD (PCRT__PTR)+ ; skip SPO
  CLA
  ST (PCRT__PTR)+ ; stack size

  ; clear stack memory
  LD $_PROC__TCB_STACK_SIZE   
  PUSH
  LD (PCRT__PTR)+ ; stack data ptr
  PUSH
  CLA
  CALL $MEMSET
  POP
  POP

  LD &proc_id
  JUMP PCRT__END
PCRT__INVALID:
  LD #0xFF

PCRT__END:
; begin epilogue
  APOP
  RET
; end epilogue
; end func PROC_INIT



; func PROC_KILL: (proc_id) kill process / stop execution
; Do not do any clear to make it lighter (PROC_CREATE would do it for us)
; 
; params: AC: proc_id
; begin globals
PKL__PTR: WORD ?
; end globals
; begin func
PROC_KILL:
  CALL $PROC_GET_TCB_PTR
  ST PKL__PTR
  LD #0xFF
  ST (PKL__PTR)
  RET
; end func PROC_KILL



; func LOAD_BIN_RUN: loads binary to ram and starts program
; Loads program at _SYS_PROC__FREE_MEM_START
; 
; begin globals
LOAD_BIN_RUN__STR_RUN: WORD "Starting program"
LOAD_BIN_RUN__JUMP_TARGET: WORD ?
; LOAD_BIN_RUN__READER: WORD $LOADER_CONSOLE_READER
LOAD_BIN_RUN__READER: WORD $LOADER_RAM_READER
; end globals
; begin func
LOAD_BIN_RUN:
  LD $_SYS_PROC__FREE_MEM_START
  PUSH
  LD LOAD_BIN_RUN__READER
  CALL $LOAD_BIN
  BZS LOAD_BIN_RUN__EXIT
  ST LOAD_BIN_RUN__JUMP_TARGET
  POP

  LD LOAD_BIN_RUN__STR_RUN_PTR
  CALL $PRINTLN
  
  JUMP (LOAD_BIN_RUN__JUMP_TARGET)
LOAD_BIN_RUN__EXIT:
  RET
; end func LOAD_BIN_RUN




; func PROC_START: () loads and starts new process
; 
; params: AC:
; return: 
; stack:
; 
; begin globals
; end globals
; begin func
PROC_START:
; begin prologue
  APUSH
; end prologue

  LD LOAD_BIN_RUN__READER
  CALL $LOAD_BIN
  BZS LOAD_BIN_RUN__EXIT
  ST LOAD_BIN_RUN__JUMP_TARGET
  POP

; begin epilogue
  APOP
  RET
; end epilogue
; end func PROC_START
