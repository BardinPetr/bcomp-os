; ----------------------------- TERMINAL INPUT -----------------------------
; func READ_LINE: (dst: word) read text string from keyboard untill enter pressed(LF):
; 
; requires: free memory of string starting from addr in param
;
; params:  AC: dst: address in memory from which the result will be placed;
; return:  AC: string length
;          MEM: string starting at mem addr "dst"
; affects: AC
; stack:   &0 - current character id
;          &1 - ret addr
; begin globals:
RL__CUR_POINTER: WORD ?    ; contains address of memory cell being currently written in output. Initialized with &3.
RL__PROMPT: WORD "> "
; end globals
; begin func
READ_LINE:
; begin prologue
  PUSH 
; end prologue

  ; set base output address from AC
  ST RL__CUR_POINTER

  ; set character id to zero 
  CLA
  ST &0

  ; LD RL__PROMPT_PTR
  ; CALL $PRINT

  ; begin loop
  RL__LOOP: 
    LD &0 ; cur id
    INC 
    ST &0 ; i++

    ; begin if
    AND #1
    BZS RL__HIGH_BYTE
    ; begin branch char_id % 2 == 0
    RL__LOW_BYTE:
      CALL $READ_CHAR
      CALL $PRINT_CHAR

      CMP #0x0A ; LF (NUL is full next word)
      BEQ RL__EOL_APPEND_NUL
      CMP #0x0D ; CR
      BEQ RL__EOL_APPEND_NUL
      CMP #0x08 ; BS
      BNE RL__CONTINUE_L
      ; begin branch on backspace pressed
        LD -(RL__CUR_POINTER)
        JUMP RL__HIGH_BYTE

      RL__CONTINUE_L:
      ST (RL__CUR_POINTER)
      JUMP RL__LOOP
    ; begin branch char_id % 2 == 1
    RL__HIGH_BYTE:
      CALL $READ_CHAR
      CALL $PRINT_CHAR

      CMP #0x0A ; LF, NUL is this word high byte
      ; no need to set NUL as it is automatically set when writing low byte
      BEQ RL__EOL
      CMP #0x0D ; CR
      BEQ RL__EOL
      CMP #0x08 ; BS
      BNE RL__CONTINUE_H
      ; begin branch on backspace pressed
        CLA
        ST (RL__CUR_POINTER)
        JUMP RL__LOW_BYTE

      RL__CONTINUE_H:
      SWAB
      OR (RL__CUR_POINTER)
      ST (RL__CUR_POINTER)+
      JUMP RL__LOOP
    ; end if
  ; end loop

RL__EOL_APPEND_NUL:
  CLA ; put EOS
  ST (RL__CUR_POINTER)
RL__EOL:
  CALL $PRINT_ENDL
  
  ; begin epilogue
    POP ; length as return in AC
    RET
  ; end epilogue
; end func READ_LINE


; func READ_CHAR: pool keyboard for ready and read 1 char from it
; 0x19,0x18 for keyboard; 0xA,0x8 for serial port
; 
; params: none
; return: AC: data read from dev in low byte
; affects: AC higher byte is cleared
; begin func
READ_CHAR:
RCH__LOOP:
  CLA
  ; IN 0x19
  IN 0xA
  AND #0x40
  BZS RCH__LOOP
  ; IN 0x18
  IN 0x8
  RET
; end func READ_CHAR