# Внесенные изменения

*На данной странице описаны изменения, предлагаемые к внедрению в БЭВМ. Причины были обнаружены при разработке минимальной операционной системы, далее на этот код будут делаться много отсылок.*


## Изменение типов адресации
Новые виды адресации представлены в таблице.

| Код (11-8б) | Мнем | Тип | Реализация |
|-|-|-|-|
| 0ХХХ | $L   | Прямая абсолютная                                | `DR -> AR; MEM(AR) -> DR`
| 1000 | &N   | Прямая относительная SP                          | `SEXT(LTOL(CR)) -> BR; BR + SP -> DR; DR -> AR; MEM(AR) -> DR` 
| 1001 | (&N) | Косвенная относительная от SP                    | `SEXT(LTOL(CR)) -> BR; BR + SP -> AR; MEM(AR) -> DR; DR -> AR; MEM(AR) -> DR`
| 1010 | (&N)+| Косвенная относительная от SP c постинкрементом  | `SEXT(LTOL(CR)) -> BR; BR + SP -> AR; MEM(AR) -> DR; DR + 1 -> DR; DR -> MEM(AR); DR - 1 -> DR; DR -> AR; MEM(AR) -> DR`
| 1011 | -(&N)| Косвенная относительная от SP с предекрементом   | `SEXT(LTOL(CR)) -> BR; BR + SP -> AR; MEM(AR) -> DR; DR - 1 -> DR; DR -> MEM(AR); DR -> AR; MEM(AR) -> DR`
| 1100 | (L)  | Косвенная относительная от IP                    | `SEXT(LTOL(CR)) -> BR; BR + IP -> AR; MEM(AR) -> DR; DR -> AR; MEM(AR) -> DR`
| 1101 | (L)+ | Косвенная относительная с постинкрементом        | `SEXT(LTOL(CR)) -> BR; BR + IP -> AR; MEM(AR) -> DR; DR + 1 -> DR; DR -> MEM(AR); DR - 1 -> DR; DR -> AR; MEM(AR) -> DR`
| 1110 | L    | Прямая относительная от IP                       | `SEXT(LTOL(CR)) -> BR; BR + IP -> DR; DR -> AR; MEM(AR) -> DR`
| 1111 |  #N  | Прямая загрузка                                  | `SEXT(LTOL(CR)) -> BR; BR -> DR`

### Причины
В ходе реализации операционной системы было выявлено, что при переключении контекста в ходе выполнения функции, которая одновременно используется несколькими процессами, и при этом, имеет свое состояние в обычных ячейках оперативной памяти, то именно это состояние не будет восстанавливаться без дополнительных действий со стороны как программы, так и ОС, то есть требовалось бы в каждой функии регистрировать данные переменный в некотором системном менеджере, который сохранял и восстанавливал бы состояние одновременно со стеком и регистрами. Но, очевидно, что это не только будет требовать напсания большого объема кода в рамках крайне ограниченной памяти, но и сильно замедлит время переключения контекста, которое и так будет значительным. 

Поэтому, в целях сохранения производительности ЭВМ и уменьшения объема кода ОС было принято решение перенести всё состояние функций полностью на стек, тогда проблема решается крайне элегантно и не требует вовсе написния нового кода. Имея весь основной набор типов адресации относительно SP можно полностью избавиться от использования глобальных переменных, так как эти подходы с функуциональной точки зрения почти идентичны. 


### Анализ 
При оценке используемых методов адресации было выявлено, что косвенная относительная предекрементная адресация применялась крайне редко, и часто - заменяемо, ее было решено убрать, тем самым освободив 4 свободных слота под адресацию относительно SP. Тем не менее данный вид адресации сохранен в режиме относительно SP, так как код был переведен на использование различных указателей полностью в качетсве переменных на стеке, то смысл в этом виде для IP полностью исчез, а для SP все еще имеет смысл в некоторых случаях обработки массивов.

Косвенная относительная постинкрементная адресация должна быть сохранена, так как есть случаи, когда работа со стеком может быть затруднена, хорошим тому примером служит переключение контекста в ОС, так как в ходе работы происходит перезапись стека и в результате либо локальные переменные затрутся, либо для них станут неочевидны смещения отнисительно SP.  


### Особенности реализации
Для оптимизации количества выполняемых микрокоманд, виды адресации относительно SP размещены последовательно так, что 10бит=0 для всех этих типов, по 9биту можно определить необходимо ли дополнительно менять значение в ячейки или сразу переходить к выборке операнда. Это позволяет не повторять микрокоманды и экономить память.
Также, косвенная относительная адресация для IP реализована полностью, а для SP только до `BR + SP -> AR; MEM(AR) -> DR` далее переиспользуется код от IP. 

### Результат
В результате внесения данных изменений удалось успешно решить поставленную задачу, при этом получив ряд преимуществ:
- Объем кода (вместе с переменными-указателями в памяти, которые более не нужны) уменьшился на 5% TODO, что особенно кричитно с учетом того, что сейчас под пользовательские программы уже осталось всего TODO слов. Причина: нет самих ячеек памяти, нет копирования агрументов со стека в память, проще разыменовывание
- Более нет необходимости в копировании ссылки, переданной в аргументы функции, во временную переменную чтобы разыменовать ее, то есть можно удобно передавать структуры по ссылке.
- Появилась возможность написания потокобезопасного кода без использования дополнительных программных компонентов управления памятью, что сокращает и время исполнения и объем кода.
- Перевод существующих программ тривиален во всех случаях, кроме убранного вида адресации, там потребуется доработка программы, но это технически сложной задачей не является. Возможно в имело смысл сохранить этот тип и не переводить его на SP для сохранения возможности автоматического перевода существующих программ, но упор в данной работе был сделан именно на функциональность и оптимизацию.
- *Изменение совместимо с учебной программой и требует минимальных изменений (заменить таблицу с типами адресации, изменить коды типов адресации с существующих демо-программах; доп материал не нужен - принцип работы у новых типов аналогичен).*


## Новый тип команд
Добавлен тип команд с единственным типом адресации - с непосредственной загрузкой 1 байт знакового операнда. Одна из таковых реализованных - SPADD, см. следующий раздел. 

### Причины и анализ
Была обнаружена необходимость в написании дополнительных микрокоманд, имеющих операнд не менее 8 бит, при этом сетка команд имеет только одну запасную адресную микрокоманду, которая предназначена для реализации студентами, а следовательно необходимо было найти дополнительный способ.

Был проведен анализ существующей системы команд посредствам подсчета количества использований в кодовой базе ОС, возможностей замены и специфичных задач, иначе нереалезуемых.

Среди адресных команд определено, что имеет смысл освободить 1 стот, использовавшийся по `SWAM`, она ни разу не была применена (дополнительно, с учетом перехода преимущественно на хранение на стеке, эта команда теряяет больше смысла), а также может быть заменена на последовательность других команд. Относительно остальных команд определено, что либо не могут быть заменены, либо их замена на эквивалентную последовательность приведет к значительному ухудшению производительности по причине частого использования. В безадресных командах принято решении не изменять состава.

Использовать под эти цели сегмент безадресных команд бесполезно, так как там используется минимум 8 бит под тип команды, при этом на 8и битном префиксе остался только 1 свободный слот, тогда возмонжо будет либо использовать более длинный префикс (как у `DEC`, `NEG` и т.д.), но тогда операнд меньше 8 бит и это в большинстве случаев бесполезно, либо необходмо освобождать адреса соединяя команды увеличивая длину префикса, тогда их исполнение будет дольше из-за дополнительных сравнений. 

### Реализация
Для исполнения был выбран сегмент FCXX-FFXX из блока команд ветвления. В рамках данной модели не было найдено смысла в реализации дополнительных команд ветвления. Поэтому под работу студентов выделены префиксы FA и FB. Тогда удобно отделять новые команды от старого сегмента - по 10 биту, при его установке получем как раз диапазон C-F на 4 команды.

Последовательность микрокоманд для нового типа начиная с момента декодирования и перехода к командам ветвления (в терминах исходного кода БЭВМ и используемых там меток):
```
BRANCHES: if CR(11) == 1 GOTO BR1XXX
BR1XXX: if CR(11) == 1 GOTO IMM8OP
IMM8OP: SEXT(LTOL(CR)) -> DR
(команды данного типа здесь)
```

### Результат 
- Появилась возможность добавлять команды с операндами, при этом не задействуя существующую систему адресации, под требования которой более не осталось свободных кодов команд
- Изменение частично совместимо с учебной программой, требует пояснений о принципах работы.


## Far-call

### Причины

Во время реализации ОС при организации системных вызовов было выявлено, что наиболле оптимальным путем будет создать глобальную таблицу функций. Также рассматривался вариант с использованием программных прерываний, но в силу малого количества веторов прерываний, пришлось бы использовать один вектор под несколько функций, передавая, например, в AC идентификатор вызываемого метода, но при этом эффективность всех таких вызовов будет ниже за счет необходимости в поиске ссылки на необходимую функцию.

### Реализация
Было рассмотрено 2 варианта - доработать существующий `CALL`, или добавить новую адресную инструкцию. В первом случае необходимо отказаться от всех типов адресации, оставив только прямую абсолютную и косвенную абсолютную с их переключением по 11 биту команды. Но это сильно нарушает совместимость с существующим подходом, а также создает проблемы при написании микрокоманд, так как если команду мы оставляем адресной (потому как больше некуда, см. предыдущий пункт), то тогда при CR[11]=0 все будет хорошо, а вот если выбираем второй вид адресации, то получаем, что команда будет декодирована уже после выборки адреса, но у нас при CR[11]=1 есть адресации с инкрементом, в их отсутствие, можно было бы смириться с оверхедом бесполезной выборки адреса и просто уже в самом CALL дописать проверку и загрузку из CR, но раз есть режимы адресации с сайд эффектами, то этого делать нельзя, чтобы не получить неопределенное поведение. 

Тогда придется использовать освобожденный из под `SWAM` слот для новой иструкции, при этом оставить единственный тип адресации для нее - косвенную абсолютную, и воизбежании вышеописанного ставить CR[11]=0.

Чтобы уменьшить объем нового кода, всю логику новой команды поместим уже в цикл исполнения бывшей SWAM. У нее есть классический цикл выборки операнда, а раз CR[11]=0 всегда, то цикл выборки адреса пустой. Тогда на самом деле задача уже выполнена и мы можем переходить к обычному CALL.

Последовательность микрокоманд для вызова `FCALL` с выборки адреса.
```
CHKABS        if CR(11) = 0 goto OPFETCH
OPFETCH:      (...)
(...)
RDVALUE:      DR -> AR
              MEM(AR) -> DR
EXEC:         if CR(15) = 1 goto CMD1XXX
CMD1XXX:      if CR(13) = 1 goto CMD101X
CMD101X:      if CR(12) = 1 goto CALL
CALL:         (...)
```

### Результат
- Расширяются возможности по организации кода.
- Изменение совместимо с учебной программой, требует лишь заменить строку в таблице команд.



## Операции с SP и IP 

В систему команд были добавлены 3 новых инструкции - RSP, WSP, SPADD.

| Код  | Мнем  | Агрумент | Реализация |
|------|-------|----------|------------|
| 0F00 | RSP   | -        | `SP -> AC` |
| 0F80 | WSP   | -        | `AC -> SP` |
| FCXX | SPADD | XX - 8 бит знаковое целочисленное | `SEXT(LTOL(CR)) -> DR; SP -> BR; BR + DR -> SP` |

### Причины
Была выявлена необходимость в изменении SP напрямую, а не инкрементом\декрементом. Это в первую очередь необходимо при переключении контекста и в прологах и эпилогах функций. При этом, если во втором случае можно обойтись `PUSH,POP,SWAP`, то в первом - это технически невозможно, так как при переключении контекста, стек должен быть переписан начиная с какого-то конкретного адреса и до также конкретного адреса, при этом текущий SP может оказаться абсолютно в любом местоположении относительно новой загруженноц вершины. Не имея возможность читать SP нельзя понять, до какого момента, например, необходимо стереть стек перед загрузкой нового. А без записи в SP, любые операции придется делать только через PUSH, что ограничивает производительность при копировании в область памяти стека, а также не позволяет произвольно менять память, а значит, придется поочередно сначала делать POP, потому PUSH, что менее эффективно в 2-3 раза по сравнению с простым копированием.  

### Особенности реализации
Так как команда SPADD полезна только в рамках прологов и эпилогов, а там не используется динамическое вычисление необходимого сдвига - он генерируется при компиляции, то делать эту команду адресной не имеет смысла, она лишь будет занимать слот среди адресных команд, где и так нет свободного места, поэтому имет смысл использовать новый тип команд - только с непосредственоой загрузкой операнда, о котором написано в соответствующем разделе. WSP и RSP решено сделать имеено так, чтобы иметь возможность получить 11 бит операнд и при этом не занимать адресный слот, решено сделать ее безадресной и использовать AC.

### Результат
- За счет прологов и эпилогов сократился обхем кода на 4% TODO
- Кратно более эффективные вызовы функций, имеющих локальные переменные на стеке
- Возможность при необходимости свободно изменять стек и при этом правильно устанавливать SP с уровня ОС
- Изменение совместимо с учебной программой и не требует изменений, достаточно внести новые команды в список.

