; string format: (char[1] char[0]) ... (char[i+1]@1b char[i]@1b) (0x00, 0x00/char[2n-1])

ORG 0x10



; --------------------INCLUDED FROM util/math.basm--------------------
; ----------------------------- MATHEMATICS LIBRARY -----------------------------

; func MUL: (a, b) unsigned numbers multiplication
; 
; params: AC a
;         STACK b (should be less than a for performance increase)
; return: a*b
; requires: a, b in range TODO
; stack: 
; &: a
; &: sum
; &: ret_addr
; &: b
; begin func
MUL:
; begin prologue
    PUSH
  PUSH

; end prologue

  ST &0
  CMP &3

  CLC
  CLA   
  ST &1

  ; begin loop
  MUL__LOOP:  
    LD &3
    BZS MUL__END

    CLC
    ROR
    ST &3
    
    ; begin if 
    BCC MUL__IF_NOT_USED
    ; begin branch if multiplier is 1 (sum)
      LD &0
      ADD &1
      ST &1

      JUMP MUL__SHIFT_A
    ; begin branch if multiplier is 0 (skip sum)
    MUL__IF_NOT_USED:
    ; end if

  MUL__SHIFT_A:  
    LD &0
    ASL
    ST &0

    JUMP MUL__LOOP
  ; end loop

  MUL__END:
; begin epilogue
    POP
  POP

  ; sum returned in ac automatically as &1 is last pop
  RET
; end func MUL

; --------------------INCLUDED END util/math.basm--------------------

; --------------------INCLUDED FROM util/string.basm--------------------
; ; func ATOI_HEX: (src) converts hex string to int 
; ; 
; ; params: AC src: pointer to NUL-ended string beginning
; ; return: AC: unsigned 2byte integer
; ; stack:  &0: current sum value
; ;         &1: current char index (from 0)
; ;         &2: ret addr
; ; begin globals
; ATOI_HEX__STR_PTR: DATA ?
; ATOI_HEX__LOW_MASK: DATA 0xFF
; ; end globals
; ; begin func
; ATOI_HEX:
; ; begin prologue
;   PUSH
;   PUSH
; ; end prologue

;   ST ATOI_STR_PTR

;   CLA 
;   ST &0
;   ST &1

;   ; begin loop
;   ATOI_HEX__LOOP:
;     LD &1

    
;     LD (ATOI_STR_PTR)
;     AND ATOI_LOW_MASK
;     CALL ATOI_CHAR

;     BZS ATOI_END
    
;     ; begin loop
;     ; ATOI_HEX__MULT:
;     ;   ASL
;     ;   ASL
;     ;   ASL
;     ;   ASL


;     JUMP ATOI_HEX__LOOP
;   ; end loop

;   ATOI_HEX__END:
; ; begin epilogue
;   POP
;   POP
;   RET
; ; end epilogue
; ; end func ATOI_HEX


; ; func ATOI: (src, radix) converts string number to int 
; ; 
; ; params: STACK src: pointer to NUL-ended string beginning
; ;         STACK radix: number radix
; ; return: AC: unsigned 2byte integer
; ; stack:  &0: radix in current power (from power 0)
; ;         &1: current sum value
; ;         &2: current char index
; ;         &3: ret addr
; ;         &4: src
; ;         &5: radix
; ; begin globals
; ATOI_STR_PTR: DATA ?
; ATOI_LOW_MASK: DATA 0xFF
; ; end globals
; ; begin func
; ATOI:
; ; begin prologue
;   PUSH
;   PUSH
; ; end prologue

;   LD &4
;   ST ATOI_STR_PTR

;   CLA 
;   ST &1
;   ST &2
;   INC
;   ST &0

;   ; begin loop
;   ATOI_LOOP:
;     LD &2

;     LD (ATOI_STR_PTR)+
;     AND ATOI_LOW_MASK
;     CALL ATOI_CHAR

;     BZS ATOI_END
    
;     PUSH
;     LD &0 ; radix in power
;     PUSH  
;     CALL $MUL ; ATOI(char[i]) * (radix ^ i)
;     POP
;     POP

;     ; save sum
;     ADD &1
;     ST &1

;     ; increase power
;     LD &0
;     PUSH
;     LD &4
;     PUSH  
;     CALL $MUL
;     POP
;     POP
;     ST &0

;     JUMP ATOI_LOOP
;   ; end loop

;   ATOI_END:
; ; begin epilogue
;   POP
;   POP
;   RET
; ; end epilogue
; ; end func ATOI


; func ATOI_CHAR: (char) returns integer representation of character with radix up to 36
; uses sequence 0,1,...,9,A(a),B(b),...,Z(z)
; params: AC char: input character
; return: AC: int value 
; begin func
ATOI_CHAR:
  ; begin if
  CMP #0x3A
  BLT ATOI_CHAR__ISNUM
  ; begin branch char >= 10
    SUB #0x37 ; A=0x41, A is 10
    
    ; begin if
    CMP #0x2A ; A=0x41, a = 0x61; 0x61-0x37 = 0x2A
    BLT ATOI_CHAR__END
    ; begin branch char in [a..z]
      SUB #0x20
      JUMP ATOI_CHAR__END
    ; end if
  ; begin branch char < 10
  ATOI_CHAR__ISNUM:
    SUB #0x30
  ; end if
ATOI_CHAR__END:
  RET
; end func ATOI_CHAR

; func ITOA_CHAR: (val) returns character representation of one digit in some radix up to 36
; uses sequence 0,1,...,9,A,B,...,Z
; params: AC val: integer input digit
; return: AC: char value 
; begin func
ITOA_CHAR:
  ; begin if
  CMP #0xA
  BLT ITOA_CHAR__ISNUM
  ; begin branch char >= 10
    ADD #0x37 ; A=0x41, A is 10
    JUMP ITOA_CHAR__END
  ; begin branch char < 10
  ITOA_CHAR__ISNUM:
    ADD #0x30
  ; end if
ITOA_CHAR__END:
  RET
; end func ITOA

; --------------------INCLUDED END util/string.basm--------------------

; --------------------INCLUDED FROM util/array.basm--------------------
; ----------------------------- ARRAYS SUPPORT LIBRARY -----------------------------

; Array is managed via functions from this library using single pointer created by
; Data is placed on heap. Any array have header before the array pointer followed by data cells



; func ARRAY_GET_FC: (src, id) get array item by index
; 
; conv: fastcall
; params: AC: src
;         STACK: id (from 0)
; return: value
; stack:
; &: ret_addr
; &: id
; begin globals
ARRAY_GET__CUR_PTR: WORD ?
; end globals
; begin func
ARRAY_GET_FC:
  ; array start in AC
  ADD &1
  ST ARRAY_GET__CUR_PTR
  LD (ARRAY_GET__CUR_PTR)

; begin epilogue
  POP
  SWAP
  LD (ARRAY_GET__CUR_PTR)
; end epilogue
  RET
; end func ARRAY_GET_FC

; func ARRAY_SET: (src, id, val) set array item by index
;
; params: AC: src
;         STACK: id (from 0)
;         STACK: val
; return: value
; stack:
; &: ret_addr
; &: id
; &: val
; begin globals
ARRAY_SET__CUR_PTR: WORD ?
; end globals
; begin func
ARRAY_SET:
  ; array start in AC
  ADD &1
  ST ARRAY_SET__CUR_PTR
  LD &2
  ST (ARRAY_SET__CUR_PTR)

  RET
; end func ARRAY_SET

; func ARRAY_LOWER_BOUND: (addr, val) lineary searches for lower bound of number in sorted array
; (maximum element that is lower than val or 0xFFFF if no such exist)
; 
; params: AC: addr
;         STACK: val
; return: lower bound of element as array index
; stack:
; &: pos
; &: ret_addr
; &: val
; begin globals
ALB__CUR_PTR: WORD ?
; end globals
; begin func
ARRAY_LOWER_BOUND:
; begin prologue
    PUSH

; end prologue

  ; addr in AC
  ST ALB__CUR_PTR

  ; get last element index  
  CALL $MSIZE
  ST &0

  ; move pointer to the element after the last
  ADD ALB__CUR_PTR
  ST ALB__CUR_PTR

  ; begin loop
  ALB__LOOP: 
    LD &2
    CMP -(ALB__CUR_PTR)
    BHIS ALB__END
    LOOP &0
    JUMP ALB__LOOP
  ; end loop

ALB__END:
  LD &0
  DEC
  ST &0 ; pos is last POP

; begin epilogue
    POP

  RET
; end epilogue
; end func ARRAY_LOWER_BOUND

; --------------------INCLUDED END util/array.basm--------------------

; --------------------INCLUDED FROM io/output.basm--------------------
; ----------------------------- TERMINAL OUTPUT -----------------------------

; func PRINT_CHAR: outputs one char to text printer with wait for device availability
; 
; params: AC - 1b character in low byte
; return: none
; begin func
PRINT_CHAR:
  PUSH ; store target char

  PCH__LOOP:
    IN 0xD
    AND #0x40
    BZS PCH__LOOP

  POP
  OUT 0xC
  RET
; end func PUT_CHAR


; func PRINT: outputs string to text printer 
; 
; requires: string encoding should be aggreed between output device and input string. 1b encoding allowed only
; params: AC - pointer to first string data address
; return: none
; stack:  &0 - ret addr
; begin globals:
PRINT__CUR: WORD ? ; pointer/iterator to currect mem address
MASK_LOW: WORD 0x00FF
; end globals
; begin func
PRINT:
  ST PRINT__CUR

; begin loop
PRINT_LOOP:
  LD (PRINT__CUR)+

  BZS PRINT_EXIT
  CALL PRINT_CHAR

  SWAB
  
  AND $MASK_LOW
  BZS PRINT_EXIT
  CALL PRINT_CHAR

  JUMP PRINT_LOOP
; end loop
PRINT_EXIT:
  RET
; end func PRINT

; --------------------INCLUDED END io/output.basm--------------------

; --------------------INCLUDED FROM io/input.basm--------------------
; ----------------------------- TERMINAL INPUT -----------------------------
; func READ_LINE: (dst: word) read text string from keyboard untill enter pressed(LF):
; 
; requires: free memory of string starting from addr in param
;
; params:  AC: dst: address in memory from which the result will be placed;
; return:  AC: string length
;          MEM: string starting at mem addr "dst"
; affects: AC
; stack:   &0 - current character id
;          &1 - ret addr
; begin globals:
RL__CUR_POINTER: WORD ?    ; contains address of memory cell being currently written in output. Initialized with &3.
; end globals
; begin func
READ_LINE:
; begin prologue
  PUSH 
; end prologue

  ; set base output address from AC
  ST $RL__CUR_POINTER

  ; set character id to zero 
  CLA
  ST &0

  ; begin loop
  RL__LOOP: 
    LD &0 ; cur id
    INC 
    ST &0 ; i++

    ; begin if
    AND #1
    BZS RL__HIGH_BYTE
    ; begin branch char_id % 2 == 0
      CALL $READ_CHAR

      CMP #0x0A ; LF (NUL is full next word)
      BEQ RL__EOL_APPEND_NUL

      ST (RL__CUR_POINTER)
      JUMP RL__LOOP
    ; begin branch char_id % 2 == 1
    RL__HIGH_BYTE:
      CALL $READ_CHAR

      CMP #0x0A ; LF, NUL is this word high byte
      ; no need to set NUL as it is automatically set when writing low byte
      BEQ RL__EOL

      SWAB
      OR (RL__CUR_POINTER)
      ST (RL__CUR_POINTER)+
      JUMP RL__LOOP
    ; end if
  ; end loop

RL__EOL_APPEND_NUL:
  CLA ; put EOS
  ST (RL__CUR_POINTER)
RL__EOL:
  ; begin epilogue
    POP ; length as return in AC
    RET
  ; end epilogue
; end func READ_LINE

; func READ_CHAR: pool keyboard for ready and read 1 char from it
;
; params: none
; return: AC: data read from dev in low byte
; affects: AC higher byte is cleared
; begin func
READ_CHAR:
RCH__LOOP:
  CLA
  IN 0x19
  AND #0x40
  BZS RCH__LOOP
  IN 0x18
  RET
; end func READ_CHAR
; --------------------INCLUDED END io/input.basm--------------------

; --------------------INCLUDED FROM os/memory.basm--------------------
; ----------------------------- DYNAMIC MEMORY MANAGEMENT -----------------------------

; memory allocation:
; 0x000 - 0x010: interrupt vectors
; 0x010 - 0xXXX: OS (loader + libs)
; 0xXXX - 0x700: user code
; 0x700 - 0x7DF: heap 224 words, 448B
; 0x7DF - 0x7FF: stack 32 words, 64B

; heap is allocated via stack allocator

; begin globals
_SYS__USERSPACE_BEGIN: WORD $_SYS__CODE_END
_SYS__USERSPACE_END: WORD 0x6FF
_SYS__HEAP_BEGIN: WORD 0x700
_SYS__HEAP_END: WORD 0x7DF
_SYS__HEAP_POINTER: WORD ?
_SYS__STACK_BEGIN: WORD 0x7E0
_SYS__STACK_END: WORD 0x7FF 
; end globals



; func MALLOC: (size): allocates size*2b memory on heap
; memory chunk is prepended with 2b word header with chunk length, returned address is the next after header
; last position in memory is tracked via pointer to the next free word after last segment
; 
; params: AC: size < 0xDF
; return: AC: allocated start address or 0 if could not allocate
; stack:
; &: size
; &: segment_addr
; &: ret_addr
; begin globals
MALLOC__HEAP_BEGIN_PTR: WORD $_SYS__HEAP_BEGIN
MALLOC__HEAP_END_PTR: WORD $_SYS__HEAP_END
MALLOC__CUR_POINTER_PTR: WORD $_SYS__HEAP_POINTER
MALLOC__WRITE_PTR: WORD ?
; end globals
; begin func
MALLOC:
; begin prologue
    PUSH
  PUSH

; end prologue

  ST &0

  ; begin if first run
  LD (MALLOC__CUR_POINTER_PTR)
  BZC MALLOC__RUN
    LD (MALLOC__HEAP_BEGIN_PTR)
    ST (MALLOC__CUR_POINTER_PTR)
  MALLOC__RUN:
  ; end if

  ; check availability
  ; begin if 
  LD (MALLOC__HEAP_END_PTR)
  SUB (MALLOC__CUR_POINTER_PTR)
  CMP &0
  BHIS MALLOC__ENOUGH_MEM
  ; begin branch (heap_end - cur_pointer) < requeted_size
  CLA
  ST &1
  JUMP MALLOC__END
  ; end if

MALLOC__ENOUGH_MEM:  
  ; prepare pointer for header
  LD (MALLOC__CUR_POINTER_PTR)
  ST MALLOC__WRITE_PTR
  INC

  ; save segment start address 
  ST &1 ; will be last POP and put in AC

  ; move pointer by size
  ADD &0
  ST (MALLOC__CUR_POINTER_PTR)

  ; store header
  LD &0
  ST (MALLOC__WRITE_PTR)


MALLOC__END:
; begin epilogue
    POP
  POP

  RET
; end epilogue
; end func MALLOC


; func MFREE: (addr) deallocates memory segment from heap
; No checks done except that this segment belongs to heap and it points to last segment, 
;   therefore user should call this method with only valid pointers allocated via MALLOC,
;   otherwise any heap data could get overriten
; params: AC: 0 for OK, 1 invalid address or when this is not a heap top
; stack:
; &: size
; &: ptr
; &: ret_addr
; begin globals
MFREE__HEAP_BEGIN_PTR: WORD $_SYS__HEAP_BEGIN
MFREE__HEAP_END_PTR: WORD $_SYS__HEAP_END
MFREE__CUR_POINTER_PTR: WORD $_SYS__HEAP_POINTER
MFREE__RW_PTR: WORD ?
; end globals
; begin func
MFREE:
; begin prologue
    PUSH
  PUSH

; end prologue

  ; ptr in AC
  ST &1
  DEC
  ST MFREE__RW_PTR

  ; read header
  LD (MFREE__RW_PTR)
  ST &0    

  ; begin if
  LD &1
  CMP (MFREE__HEAP_BEGIN_PTR)
  BLO MFREE__INVALID_PTR

  ADD &0
  CMP (MFREE__CUR_POINTER_PTR)
  BNE MFREE__INVALID_PTR
  JUMP MFREE__CONTINUE
  ; begin branch if ptr < _SYS__HEAP_BEGIN || (ptr+size) != _SYS__HEAP_POINTER
  MFREE__INVALID_PTR:
    LD #1
    ST &1
    JUMP MFREE__END
  ; end if

MFREE__CONTINUE:
  ; update global pointer
  LD &1
  DEC
  ST (MFREE__CUR_POINTER_PTR)

  ; ok ret code
  CLA
  ST &1

MFREE__END:
; begin epilogue
    POP
  POP

  RET
; end epilogue
; end func MFREE


; func MSIZE: (addr) returns length of allocated memory segment
; 
; params: AC: addr
; return: AC: length
; stack:
; 
; begin globals
MSIZE__READ_PTR: WORD ?
; end globals
; begin func
MSIZE:
  DEC
  ST MSIZE__READ_PTR
  LD (MSIZE__READ_PTR)
  RET
; end func MSIZE

; --------------------INCLUDED END os/memory.basm--------------------

; --------------------INCLUDED FROM os/loader.basm--------------------
; ----------------------------- DYNAMIC PROGRAM LOADER -----------------------------

; func LOAD_BIN: loads programm from binary to RAM and relocates sectors sequentially.
; Changes all absolute address commands to point into relocated addresses.
; Indirect addressing should be used inside single sector only.
; Remap of poiners created via "DATA $X" construction is not supported.
; Uses LB__NEXT_INPUT_WORD_PTR as streaming source of 2b words for binary.
; Program is loaded from LB__LOAD_POINT up to LB__USERSPACE_END.
; 
; return: AC: start address of program  
; stack:
; &: org_array
; &: len_array
; &: delta_array
; &: cur_cmd
; &: cur_section_org_delta
; &: cur_section_len
; &: cur_section_cnt
; &: real_org
; &: start_addr
; &: section_cnt
; &: ret_addr
; begin globals
LB__NEXT_INPUT_WORD_PTR: WORD $READ_WORD_DEMO
LB__USERSPACE_BEGIN_PTR: WORD $_SYS__USERSPACE_BEGIN
LB__USERSPACE_END_PTR: WORD $_SYS__USERSPACE_END
LB__LOAD_PTR: WORD ?
LB__LEN_ARRAY_PTR: WORD ?
LB__ORG_ARRAY_PTR: WORD ?
LB__DELTA_ARRAY_PTR: WORD ?
LB__START_CMD_FIX: WORD 0x2000
; end globals
; begin func
LOAD_BIN:
  ; begin prologue
    PUSH
  PUSH
  PUSH
  PUSH
  PUSH
  PUSH
  PUSH
  PUSH
  PUSH
  PUSH

  ; end prologue
  LD $LB__STR_STARTED_PTR
  CALL $PRINT

  CALL (LB__NEXT_INPUT_WORD_PTR)
  ST &9
  ST &6

  ; allocate arrays
  CALL $MALLOC
  ST &1
  ST LB__LEN_ARRAY_PTR

  LD &9
  CALL $MALLOC
  ST &2
  ST LB__DELTA_ARRAY_PTR

  LD &9
  CALL $MALLOC
  ST &0
  ST LB__ORG_ARRAY_PTR
  ; end alloc

  CALL (LB__NEXT_INPUT_WORD_PTR)
  ST &8

  LD (LB__USERSPACE_BEGIN_PTR)
  ST LB__LOAD_PTR
  ST &7

  ; begin loop over sections
  LB__LOAD_SECT_LOOP:    
    CALL (LB__NEXT_INPUT_WORD_PTR)
    ; offset not used

    CALL (LB__NEXT_INPUT_WORD_PTR)
    ST (LB__LEN_ARRAY_PTR)+
    ASL
    ASR
    ST &5

    CALL (LB__NEXT_INPUT_WORD_PTR)
    ST (LB__ORG_ARRAY_PTR)+

    ; calculate org delta (section_org - real_section_org)
    SUB &7
    ST (LB__DELTA_ARRAY_PTR)+

    ; increase targer org counter
    LD &7
    ADD &5
    ST &7

    ; begin if check memory availability
    CMP (LB__USERSPACE_END_PTR)
    BLT LB__SECTION_VALID 
    ; begin branch section out of space
      LD $LB__STR_NO_SPACE_PTR
      CALL $PRINT
      JUMP LB__END
    ; end if

    LB__SECTION_VALID:
    LOOP &6
    JUMP LB__LOAD_SECT_LOOP
  ; end loop over sections

  ; inform
  LD $LB__STR_HEADER_OK_PTR
  CALL $PRINT

  ; restart sections iteration
  LD &9
  ST &6

  ; restart len array iterator
  LD &1
  ST LB__LEN_ARRAY_PTR

  ; begin loop over sections
  LB__SECT_LOOP:    
    LD (LB__LEN_ARRAY_PTR)+
    ST &5
    
    ; begin if cur_section_len[15]
    ROL
    BCS LB__CODE_SEC
    ; begin branch if data sector
      ; remove executable marker
      LD &5
      ASL
      ASR
      ST &5

      ; begin loop over data
      LB__DATA_CMD_LOOP:
        CALL (LB__NEXT_INPUT_WORD_PTR)
        ST (LB__LOAD_PTR)+

        LOOP &5
        JUMP LB__DATA_CMD_LOOP
      ; end loop over data
      JUMP LB__SEC_RELOC_END
    ; end branch
    ; begin branch if code sector
    LB__CODE_SEC:
      ; begin loop over commands
      ; remove executable marker
      LD &5
      ASL
      ASR
      ST &5
      LB__CODE_CMD_LOOP:
        CALL (LB__NEXT_INPUT_WORD_PTR) ; load command
        ST &3

        LD &0
        PUSH 
        LD &3
        PUSH 
        LD &5
        CALL $LOAD_BIN_FIX_CMD

        ST (LB__LOAD_PTR)+ 

        POP
        POP        

        LOOP &5
        JUMP LB__CODE_CMD_LOOP
      ; end loop over commands

    ; end if
    LB__SEC_RELOC_END:

    LD &9
    SUB &6
    CALL $ITOA_CHAR
    CALL $PRINT_CHAR

    LD $LB__STR_SECTION_LOADED_PTR
    CALL $PRINT

    LOOP &6
    JUMP LB__SECT_LOOP
  ; end loop over sections

LB__END:
  LD $LB__STR_FULL_LOADED_PTR
  CALL $PRINT

  ; deallocate arrays
  LD &0
  CALL $MFREE
  LD &2
  CALL $MFREE
  LD &1
  CALL $MFREE

  ; calculate new start address and return in AC
  LD &0
  PUSH 
  LD &3
  PUSH 
  LD &10
  OR LB__START_CMD_FIX ; make it look like absolute addressed command for reuse
  CALL $LOAD_BIN_FIX_CMD
  
  SUB LB__START_CMD_FIX
  ST &11 ; store to next stack item after ret addr so last POP will put it in AC
  POP
  POP

; begin epilogue
    POP
  POP
  POP
  POP
  POP
  POP
  POP
  POP
  POP
  POP

  RET
; end epilogue

; begin globals strings 
LB__STR_STARTED: WORD 0x7453, 0x7261, 0x6574, 0x2064, 0x6F6C, 0x6461, 0x6E69, 0x2067, 0x7270, 0x676F, 0x6172, 0x0A6D, 0x000D
      LB__STR_STARTED_PTR: WORD $LB__STR_STARTED
LB__STR_NO_SPACE: WORD 0x6F4E, 0x2074, 0x6E65, 0x756F, 0x6867, 0x5220, 0x4D41, 0x7420, 0x206F, 0x6F6C, 0x6461, 0x7020, 0x6F72, 0x7267, 0x6D61, 0x0D0A, 0x0000
      LB__STR_NO_SPACE_PTR: WORD $LB__STR_NO_SPACE
LB__STR_HEADER_OK: WORD 0x6548, 0x6461, 0x7265, 0x7020, 0x7261, 0x6573, 0x2064, 0x6E61, 0x2064, 0x6176, 0x696C, 0x0A64, 0x000D
      LB__STR_HEADER_OK_PTR: WORD $LB__STR_HEADER_OK
LB__STR_SECTION_LOADED: WORD 0x7320, 0x6365, 0x6974, 0x6E6F, 0x6C20, 0x616F, 0x6564, 0x0A64, 0x000D
      LB__STR_SECTION_LOADED_PTR: WORD $LB__STR_SECTION_LOADED
LB__STR_FULL_LOADED: WORD 0x6F4C, 0x6461, 0x6E69, 0x2067, 0x7573, 0x6363, 0x7365, 0x6673, 0x6C75, 0x0D0A, 0x0000
      LB__STR_FULL_LOADED_PTR: WORD $LB__STR_FULL_LOADED
; end globals
; end func LOAD_BIN



; func LOAD_BIN_FIX_CMD: (cmd, delta_array, org_array)
; 
; params: AC: cmd
;         STACK: org_array: pointer to array of section ORGs
;         STACK: delta_array: pointer to array of section ORG deltas
; return:
; stack:
; &: org_delta
; &: cur_cmd
; &: ret_addr
; &: delta_array
; &: org_array
; begin globals
LBFC__CMD_ADDR_TYPE_MASK: WORD 0x0800 ; (0000 1000 0000 0000)
LBFC__CMD_ADDRESS_MASK: WORD 0x7FF
LBFC__ABS_CMD_MIN_VAL: WORD 0x2000
LBFC__ABS_CMD_MAX_VAL: WORD 0xF000
; end globals
; begin func
LOAD_BIN_FIX_CMD:
; begin prologue
    PUSH
  PUSH

; end prologue

  ST &1

  ; begin if addressed : CMD >= 0x2000, CMD < 0xF000,  absolute: CMD[11]=0
  CMP LBFC__ABS_CMD_MAX_VAL  
  BHIS LBFC__OTHER_CMD
  CMP LBFC__ABS_CMD_MIN_VAL
  BLO LBFC__OTHER_CMD
  AND LBFC__CMD_ADDR_TYPE_MASK
  BZC LBFC__OTHER_CMD_DO_RELOAD
  ; begin branch absolute addressing
    LD &1
    AND LBFC__CMD_ADDRESS_MASK
    
    PUSH ; cmd's address part
    LD &5
    CALL $ARRAY_LOWER_BOUND
    ST &1 ; index
    POP

    LD &0
    PUSH 
    LD &4
    CALL $ARRAY_GET_FC
    ST &0 ; real delta

    ; (cur_cmd - org_delta) = (cmd_id + section_org) - (section_org - real_section_org) = cmd_id + real_section_org
    LD &1
    SUB &0
    ST &1 
    JUMP LBFC__OTHER_CMD
  ; begin branch not absolute addressing
  LBFC__OTHER_CMD_DO_RELOAD:
    LD &1
  LBFC__OTHER_CMD:
  ; end if

; begin epilogue
    POP
  POP

  RET
; end epilogue
; end func LOAD_BIN_FIX_CMD

; --------------------INCLUDED END os/loader.basm--------------------
JUMP_TARGET: WORD ?
LENS: WORD 0x1F, 0x20, 0x21
LENSP: WORD $LENS
ALCS: WORD 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
ALCSP: WORD $ALCS
START:
  CALL $LOAD_BIN
  ST JUMP_TARGET
  JUMP (JUMP_TARGET)
  HLT


READ_WORD_DEMO_PTR: WORD $BIN
READ_WORD_DEMO:
  LD (READ_WORD_DEMO_PTR)+
  RET


BIN: WORD 0x0002, 0x0100, 0x0000, 0x8004, 0x0100, 0x0004, 0x0001, 0x0200, 0xA200, 0x0000, 0x130C, 0x0100, 0x00E8


_SYS__CODE_END: WORD 0

