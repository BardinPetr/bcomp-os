; ----------------------------- DYNAMIC PROGRAM LOADER -----------------------------

; func LOAD_BIN: (read_func) loads programm from binary to RAM and relocates sectors sequentially.
; Changes all absolute address commands to point into relocated addresses.
; Indirect addressing should be used inside single sector only.
; Remap of poiners created via "DATA $X" construction is supported only when they have 15 bit set.
; Uses LB__NEXT_INPUT_WORD_PTR as streaming source of 2b words for binary.
; Program is loaded from LB__LOAD_POINT up to LB__USERSPACE_END.
; 
; params: AC: read_func: function returning 1 word from binarry each time called
; return: AC: start address of program or 0x0 if failed
; stack:
; &: org_array
; &: len_array
; &: delta_array
; &: cur_cmd
; &: cur_section_org_delta
; &: cur_section_len
; &: cur_section_cnt
; &: real_org
; &: start_addr
; &: section_cnt
; &: ret_addr
; begin globals
LB__NEXT_INPUT_WORD_PTR: WORD ?
LB__USERSPACE_BEGIN_PTR: WORD $_SYS__USERSPACE_BEGIN
LB__USERSPACE_END_PTR: WORD $_SYS__USERSPACE_END
LB__LOAD_PTR: WORD ?
LB__LEN_ARRAY_PTR: WORD ?
LB__ORG_ARRAY_PTR: WORD ?
LB__DELTA_ARRAY_PTR: WORD ?
LB__START_CMD_FIX: WORD 0x2000
; end globals
; begin func
LOAD_BIN:
  ; begin prologue
  APUSH
  ; end prologue
  ST LB__NEXT_INPUT_WORD_PTR

  LD $LB__STR_STARTED_PTR
  CALL $PRINTLN

  CALL (LB__NEXT_INPUT_WORD_PTR)
  ST &section_cnt
  ST &cur_section_cnt

  ; allocate arrays
  CALL $MALLOC
  ST &len_array
  ST LB__LEN_ARRAY_PTR

  LD &section_cnt
  CALL $MALLOC
  ST &delta_array
  ST LB__DELTA_ARRAY_PTR

  LD &section_cnt
  CALL $MALLOC
  ST &org_array
  ST LB__ORG_ARRAY_PTR
  ; end alloc

  CALL (LB__NEXT_INPUT_WORD_PTR)
  ST &start_addr

  LD (LB__USERSPACE_BEGIN_PTR)
  ST LB__LOAD_PTR
  ST &real_org

  ; begin loop over sections
  LB__LOAD_SECT_LOOP:    
    CALL (LB__NEXT_INPUT_WORD_PTR)
    ; offset not used

    CALL (LB__NEXT_INPUT_WORD_PTR)
    ST (LB__LEN_ARRAY_PTR)+
    ASL
    ASR
    ST &cur_section_len

    CALL (LB__NEXT_INPUT_WORD_PTR)
    ST (LB__ORG_ARRAY_PTR)+

    ; calculate org delta (section_org - real_section_org)
    SUB &real_org
    ST (LB__DELTA_ARRAY_PTR)+

    ; increase targer org counter
    LD &real_org
    ADD &cur_section_len
    ST &real_org

    ; begin if check memory availability
    CMP (LB__USERSPACE_END_PTR)
    BLT LB__SECTION_VALID 
    ; begin branch section out of space
      LD $LB__STR_NO_SPACE_PTR
      CALL $PRINTLN
      CLA ; err return code
      ST &section_cnt
      JUMP LB__END
    ; end if

    LB__SECTION_VALID:
    LOOP &cur_section_cnt
    JUMP LB__LOAD_SECT_LOOP
  ; end loop over sections

  ; inform
  LD $LB__STR_HEADER_OK_PTR
  CALL $PRINT

  LD &section_cnt
  CALL $ITOA_CHAR ; TODO ITOA
  CALL $PRINT_CHAR
  CALL $PRINT_ENDL

  ; restart sections iteration
  LD &section_cnt
  ST &cur_section_cnt

  ; restart len array iterator
  LD &len_array
  ST LB__LEN_ARRAY_PTR

  ; begin loop over sections
  LB__SECT_LOOP:    
    LD (LB__LEN_ARRAY_PTR)+
    ST &cur_section_len
    
    ; begin if cur_section_len[15]
    ROL
    BCS LB__CODE_SEC
    ; begin branch if data sector
      ; remove executable marker
      LD &cur_section_len
      ASL
      ASR
      ST &cur_section_len

      ; begin loop over data
      LB__DATA_CMD_LOOP:
        CALL (LB__NEXT_INPUT_WORD_PTR)
        ST (LB__LOAD_PTR)+

        LOOP &cur_section_len
        JUMP LB__DATA_CMD_LOOP
      ; end loop over data
      JUMP LB__SEC_RELOC_END
    ; end branch
    ; begin branch if code sector
    LB__CODE_SEC:
      ; begin loop over commands
      ; remove executable marker
      LD &cur_section_len
      ASL
      ASR
      ST &cur_section_len
      LB__CODE_CMD_LOOP:
        CALL (LB__NEXT_INPUT_WORD_PTR) ; load command
        ST &cur_cmd

        LD &org_array
        PUSH 
        LD &delta_array+1
        PUSH 
        LD &cur_cmd+2
        CALL $LOAD_BIN_FIX_CMD

        ST (LB__LOAD_PTR)+ 

        POP
        POP        

        LOOP &cur_section_len
        JUMP LB__CODE_CMD_LOOP
      ; end loop over commands

    ; end if
    LB__SEC_RELOC_END:

    LD &section_cnt
    SUB &cur_section_cnt
    CALL $ITOA_CHAR ; TODO: use ITOA
    CALL $PRINT_CHAR
    LD $LB__STR_SECTION_LOADED_PTR
    CALL $PRINTLN

    LOOP &cur_section_cnt
    JUMP LB__SECT_LOOP
  ; end loop over sections

  LD $LB__STR_FULL_LOADED_PTR
  CALL $PRINTLN

  ; calculate new start address and return in AC
  LD &org_array
  PUSH 
  LD &delta_array+1
  PUSH 
  LD &start_addr+2
  OR LB__START_CMD_FIX ; make it look like absolute addressed command for reuse
  CALL $LOAD_BIN_FIX_CMD
  
  SUB LB__START_CMD_FIX
  ST &section_cnt+2 ; store to next stack item after ret addr so last POP will put it in AC
  POP
  POP

LB__END:
  ; deallocate arrays
  LD &org_array
  CALL $MFREE
  LD &delta_array
  CALL $MFREE
  LD &len_array
  CALL $MFREE

; begin epilogue
  APOP
  RET
; end epilogue

; begin globals strings 
LB__STR_STARTED: WORD "Started loading program"
LB__STR_NO_SPACE: WORD "Not enough RAM to load program"
LB__STR_HEADER_OK: WORD "Header parsed and valid. Sections count: "
LB__STR_SECTION_LOADED: WORD " section loaded"
LB__STR_FULL_LOADED: WORD "Loading successful"
; end globals
; end func LOAD_BIN




; func LOAD_BIN_FIX_CMD: (cmd, delta_array, org_array)
; 
; params: AC: cmd
;         STACK: org_array: pointer to array of section ORGs
;         STACK: delta_array: pointer to array of section ORG deltas
; return:
; stack:
; &: org_delta
; &: cur_cmd
; &: ret_addr
; &: delta_array
; &: org_array
; begin globals
LBFC__CMD_ADDR_TYPE_MASK: WORD 0x0800 ; (0000 1000 0000 0000)
LBFC__CMD_ADDRESS_MASK: WORD 0x7FF
LBFC__ABS_CMD_MIN_VAL: WORD 0x2000
LBFC__ABS_CMD_MAX_VAL: WORD 0xF000
; end globals
; begin func
LOAD_BIN_FIX_CMD:
; begin prologue
  APUSH
; end prologue

  ST &cur_cmd

  ; begin if addressed : CMD >= 0x2000, CMD < 0xF000,  absolute: CMD[11]=0
  CMP LBFC__ABS_CMD_MAX_VAL  
  BHIS LBFC__OTHER_CMD
  CMP LBFC__ABS_CMD_MIN_VAL
  BLO LBFC__OTHER_CMD
  AND LBFC__CMD_ADDR_TYPE_MASK
  BZC LBFC__OTHER_CMD_DO_RELOAD
  ; begin branch absolute addressing
    LD &cur_cmd
    AND LBFC__CMD_ADDRESS_MASK
    
    PUSH ; cmd's address part
    LD &org_array+1
    CALL $ARRAY_LOWER_BOUND
    ST &org_delta+1 ; index
    POP

    LD &org_delta
    PUSH 
    LD &delta_array+1
    CALL $ARRAY_GET_FC
    ST &org_delta ; real delta

    ; (cur_cmd - org_delta) = (cmd_id + section_org) - (section_org - real_section_org) = cmd_id + real_section_org
    LD &cur_cmd
    SUB &org_delta
    ST &cur_cmd 
    JUMP LBFC__OTHER_CMD
  ; begin branch not absolute addressing
  LBFC__OTHER_CMD_DO_RELOAD:
    LD &cur_cmd
  LBFC__OTHER_CMD:
  ; end if

; begin epilogue
  APOP
  RET
; end epilogue
; end func LOAD_BIN_FIX_CMD



; func LOAD_BIN_RUN: loads binary to ram and starts program
; 
; begin globals
LOAD_BIN_RUN__STR_RUN: WORD "Starting program"
LOAD_BIN_RUN__JUMP_TARGET: WORD ?
LOAD_BIN_RUN__READER: WORD $LOADER_CONSOLE_READER
; LOAD_BIN_RUN__READER: WORD $LOADER_RAM_READER
; end globals
; begin func
LOAD_BIN_RUN:
  LD LOAD_BIN_RUN__READER
  CALL $LOAD_BIN
  BZS LOAD_BIN_RUN__EXIT
  ST LOAD_BIN_RUN__JUMP_TARGET
  
  LD LOAD_BIN_RUN__STR_RUN
  CALL $PRINTLN
  
  JUMP (LOAD_BIN_RUN__JUMP_TARGET)
LOAD_BIN_RUN__EXIT:
  RET
; end func LOAD_BIN_RUN
