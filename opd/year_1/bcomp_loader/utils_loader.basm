; ----------------------------- DYNAMIC PROGRAM LOADER -----------------------------

; func LOAD_BIN:
; 
; stack:
; &: cur_cmd
; &: cur_section_org_delta
; &: cur_section_len
; &: cur_section_offset
; &: cur_section_org
; &: cur_section_cnt
; &: real_org
; &: start_addr
; &: section_cnt
; &: ret_addr
; begin globals
LB__CMD_ADDR_TYPE_MASK: WORD 0x0800 ; (0000 1000 0000 0000)
LB__ABS_CMD_MIN_VAL: WORD 0x2000
LB__ABS_CMD_MAX_VAL: WORD 0xF000
LB__USERSPACE_END: WORD 0x700
LB__NEXT_INPUT_WORD: WORD $READ_WORD_DEMO
LB__LOAD_POINT: WORD $CODE_END_PTR ; address of userspace memory beginning  
LB__LOAD_PTR: WORD $LB__LOAD_POINT
; end globals
; begin func
LOAD_BIN:
  ; begin prologue
  PUSHA
  ; end prologue
  
  CALL (LB__NEXT_INPUT_WORD)
  ST &section_cnt
  ST &cur_section_cnt

  CALL (LB__NEXT_INPUT_WORD)
  ST &start_addr

  LD LB__LOAD_PTR
  ST &real_org

  ; begin loop over sections
  LB__LOAD_SECT_LOOP:    
    CALL (LB__NEXT_INPUT_WORD)
    ST &cur_section_offset

    CALL (LB__NEXT_INPUT_WORD)
    ST &cur_section_len
  
    CALL (LB__NEXT_INPUT_WORD)
    ST &cur_section_org
    ; calculate org delta (section_org - real_section_org)
    SUB &real_org
    ST &cur_section_org_delta

    ; increase targer org counter
    LD &real_org
    ADD &cur_section_len
    ST &real_org

    ; begin if check memory availability
    CMP LB__USERSPACE_END
    BLT LB__SECTION_VALID 
    ; begin branch section out of space
      LD LB__STR_NO_SPACE_PTR
      CALL PRINT
      JUMP LB__END
    ; end if

    LB__SECTION_VALID:
    LOOP &cur_section_cnt
    JUMP LB__LOAD_SECT_LOOP
  ; end loop over sections

  LD LB__STR_HEADER_OK_PTR
  CALL PRINT


  ; restart sections iteration
  LD &section_cnt
  ST &cur_section_cnt

  ; begin loop over sections
  LB__SECT_LOOP:    
    LD #0 ; load cur_section_offset
    
    ; begin if cur_section_offset[15]
    ROL
    BCS LB__CODE_SEC
    ; begin branch if data sector

      ; begin loop over commands
      LB__DATA_CMD_LOOP:
        CALL (LB__NEXT_INPUT_WORD)
        ST (LB__LOAD_PTR)+

        LOOP &cur_section_len
        JUMP LB__DATA_CMD_LOOP
      ; end loop over commands


    ; begin branch if code sector
    LB__CODE_SEC:

      ; begin loop over commands
      LB__CODE_CMD_LOOP:
        CALL (LB__NEXT_INPUT_WORD) ; load command
        ST &cur_cmd

        ; TODO set cur_section_org_delta

        ; begin if addressed : CMD >= 0x2000, CMD < 0xF000,  absolute: CMD[11]=0
        CMP LB__ABS_CMD_MAX_VAL  
        BGE LB__OTHER_CMD
        CMP LB__ABS_CMD_MIN_VAL
        BLT LB__OTHER_CMD
        AND LB__CMD_ADDR_TYPE_MASK
        BZC LB__OTHER_CMD
        ; begin branch absolute addressing
          ; (cur_cmd - org_delta) = (cmd_id + section_org) - (section_org - real_section_org) = cmd_id + real_section_org
          LD &cur_cmd
          SUB &cur_section_org_delta 
        ; begin branch not absolute addressing
        LB__OTHER_CMD:
          LD (LB__LOAD_PTR)+ ; just for increment
        ; end if

        LOOP &cur_section_len
        JUMP LB__CODE_CMD_LOOP
      ; end loop over commands

    ; end if
    LOOP &section_cnt
    JUMP LB__SECT_LOOP
  ; end loop over sections

LB__END:
; begin epilogue
  POPA
  RET
; end epilogue

; begin globals strings 
LB__STR_NO_SPACE: WORD "not enough RAM to load program\n"
LB__STR_HEADER_OK: WORD "header parsed and valid\n"
; end globals
; end func LOAD_BIN
